# User Guide

_*Note:*_ Some sections of this guide may be out of date, but will be updated
soon.

It is highly recommend to read the gRPC "Getting Started" documentation found
[here](http://www.grpc.io/docs/) before continuing.

This guide describes how to use Gorums as a user. The guide requires a working
Go installation and that ```$GOPATH/bin``` is in your ```$PATH```. At least Go
version 1.6 is required due to use of vendoring.

We will in this example create a very simple register service.  The register
can store a single ```{string,timestamp}``` tuple and has two methods:

* Read() State
* Write(State) Response

The first thing we should do is to define our register as a gRPC service by
using the protocol buffers interface definition language. Let's create a file,
```register.proto```, in a new Go package called ```gorumsexample```. The
package file path may for example be
```
$GOPATH/src/github.com/yourusername/gorumsexample
``` 
The file ```register.proto``` should have the following content:

```protobuf
syntax = "proto3";

package gorumsexample;

service Register {
	rpc Read(ReadRequest) returns (State) {}
	rpc Write(State) returns (WriteResponse) {}
}

message State {
	string Value = 1;
	int64 Timestamp = 2;
}

message WriteResponse {
	bool New = 1;
}

message ReadRequest {}
```

Every protobuf RPC method must take and return a single protobuf message. The
```Read``` method must in this example therefore take an empty "dummy"
```ReadRequest``` as input.

We should next compile our service definition into Go code which includes:

1. Go code to access and manage the defined protobuf messages.
2. A gRPC client API and server interface for the register.
3. A Gorums client API for the register.

To do so we need all dependencies installed. Version 3 of ```protoc```, the
Protocol Buffers Compiler is needed. Installation of this tool is
OS/distribution specific. See
[releases](https://github.com/google/protobuf/releases) and
[documentation](https://developers.google.com/protocol-buffers/). The other
dependencies are:

* [Go support](https://github.com/gogo/protobuf) for protocol buffers.
* [gRPC-Go:](https://github.com/grpc/grpc-go) The Go implementation of gRPC.

Installing the above dependencies is automated by using a provided Makefile.
You should fist download this repository if you have already done so. It can be
done in two ways:

```shell
	$ go get github.com/relab/gorums
	# TODO: This only works if the repository is public.
```

```shell
	$ mkdir -p $GOPATH/src/github.com/relab
	$ cd $GOPATH/src/github.com/relab
	$ git clone git@github.com:relab/gorums.git
```

The dependencies listed above can now be downloaded and installed by invoking
the ```deps``` target in the Makefile found in the repository:

```shell
	$ make deps
```

We can now invoke ```protoc``` to compile our protobuf definition:

```shell
	$ cd GOPATH/src/github.com/yourusername/gorumsexample
	$ protoc --gorums_out=plugins=grpc+gorums:. register.proto
```

You should now have a file named ```register.pb.go``` in your package
directory. This file contains the generated Gorums client API. Our two RPC
methods have the following signatures:

```go
func (c *Configuration) Read(args *ReadRequest) (*ReadReply, error)

func (c *Configuration) Write(args *State) (*WriteReply, error)
```

**Note:** You should for a real use case keep the `proto` and generated `pb.go`
files in a separate directory and import the generate Gorums API as a sub
package into to your main application. We skip this step in this example for
the sake of simplicity.

Our server side register interface is generated by the gRPC plugin:

```go
type RegisterServer interface {
	Read(context.Context, *ReadRequest) (*State, error)
	Write(context.Context, *State) (*WriteResponse, error)
}
```

The implementation of this interface and running the servers is not described
here. See
[reg_server_udef.go](https://github.com/relab/gorums/blob/master/dev/reg_server_udef.go)
for an example implementation and
[config_rpc_test.go](https://github.com/relab/gorums/blob/master/dev/config_rpc_test.go).
for how to run at set of servers.

We will now describe how to use the generated Gorums API. The first thing we
need to do is to create an instance of the Manager type. The Manager maintains
a connection to all the provided nodes and also keep track of every
configuration of nodes. It takes as arguments a list of node addresses and a
set of optional manager options.

We can forward gRPC dial options to the Manager if needed. The Manager will use
these options when connecting to the other nodes. Three different options are
specified in the example below. It is also possible to specify a custom quorum
function for each available RPC method as a manager option.  Custom quorum
functions may require a bit more elaboration. A Gorums quorum function has two
responsibilities:

1. Report when a set of replies form a quorum.

2. Pick a single reply from a set of replies that form a quorum.

Behind the scenes a quorum RPC returns one or more replies depending on the
configuration quorum size. Only one of these replies should be returned to the
end user. However, how such a single reply should be chosen is application
specific, and not something Gorums can generically provide a policy for. It would
be natural to for example compare message content when deciding which reply to
return to the user. Gorums provides a basic default quorum function for each
generated RPC method. These functions all employ the following policy:

1. Reports a quorum if the number of received replies is equal or greater to
   the configuration quorum size.

2. Chooses the first reply in a list of replies as the return value to the user
   if it reports a quorum.

It is important to note that every quorum function is "tied" to the RPC method
itself, not the configuration the RPC method is invoked on. This means that
every `Configuration` instance shares that same quorum function for every
service RPC method. The configuration invoking the RPC method is passed as an
argument to every quorum function so that configuration information such as
quorum size can be accessed by the function.

We specify in the example below a custom quorum function for the `Read` RPC
method only. `Write` use implicitly the default function generated by Gorums.
The custom quorum function in the example below reports no quorum if the number
of replies if less than the configuration quorum size. If the number of replies
is greater or equal to the configuration quorum size, the function sorts the
`*State` replies based on the timestamp field, and returns the `*State` reply
with the greatest timestamp and a boolean set to `true` indicating that a
quorum was found. The custom quorum function is finally passed as an option to
the `NewManager` constructor.

```go
package gorumsexample

import (
	"log"
	"time"

	"google.golang.org/grpc"
)

type ByTimestamp []*State

func (a ByTimestamp) Len() int           { return len(a) }
func (a ByTimestamp) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByTimestamp) Less(i, j int) bool { return a[i].Timestamp < a[j].Timestamp }

func ExampleRegisterClient() {
	addrs := []string{
		"127.0.0.1:8080",
		"127.0.0.1:8081",
		"127.0.0.1:8082",
	}

	// Define a custom quorum function for the Read RPC method.
	// Passed as an option to the Manager below.
	rqfn := func(c *Configuration, replies []*State) (*State, bool) {
		if len(replies) < c.Quorum() {
			return nil, false
		}
		sort.Sort(ByTimestamp(replies))
		return replies[len(replies)-1], true
	}

	mgr, err := NewManager(addrs, WithGrpcDialOptions(
		grpc.WithBlock(),
		grpc.WithTimeout(50*time.Millisecond),
		grpc.WithInsecure(),
		),
		WithReadQuorumFunc(rqfn),
	)
	if err != nil {
		log.Fatal(err)
	}
```

A configuration is a set of nodes with a defined quorum size on which our
RPC calls can be invoked. The manager assigns every node and configuration a
unique id. The code below show how to create two different configurations:

```go 
	// Get all all available node ids, 3 nodes
	ids := mgr.IDs()

	// A read configuration. Quorum=1, n=3
	readConfig, err := mgr.NewConfiguration(ids, 1)
	if err != nil {
		log.Fatalln("error creating read config:", err)
	}

	// A write configuration. Quorum=2, n=3
	writeConfig, err := mgr.NewConfiguration(ids, 2)
	if err != nil {
		log.Fatalln("error creating write config:", err)
	}
```

The ```Manager``` and ```Configuration``` type also have other available
methods. Se godoc or source code for details.

We can now finally invoke a read or write quorum RPC on each of our two
configurations:

```go
	// Test state
	state := &State{
		Value:     "42",
		Timestamp: time.Now().Unix(),
	}

	// Do write call
	wreply, err := writeConfig.Write(state)
	if err != nil {
		log.Println("write rpc call error:", err)
	}
	log.Println("write rpc reply:", wreply)

	// Do read call
	rreply, err := readConfig.Read(&ReadRequest{})
	if err != nil {
		log.Println("read rpc call error:", err)
	}
	log.Println("read rpc reply:", rreply)
```

A reply has the type name "RPCMethodName" + "Reply". A reply contains a single
reply of the appropriate type for this RPC method. It additionally also
contains a slice with the id of every node that is a part of the quorum that
replied. 
